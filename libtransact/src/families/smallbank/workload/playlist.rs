/*
 * Copyright 2017 Intel Corporation
 * Copyright 2021 Cargill Incorporated
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ------------------------------------------------------------------------------
 */

//! Tools for generating YAML playlists of transactions and continous payloads
use std::borrow::Cow;
use std::fmt;
use std::io::Read;
use std::io::Write;
use std::time::Instant;

use cylinder::Signer;
use protobuf::Message;
use rand::distributions::Standard;
use rand::prelude::*;
use sha2::{Digest, Sha512};
use yaml_rust::yaml::Hash;
use yaml_rust::Yaml;
use yaml_rust::YamlEmitter;
use yaml_rust::YamlLoader;

use crate::protocol::sabre::ExecuteContractActionBuilder;
use crate::protocol::smallbank;
use crate::protocol::smallbank::SmallbankTransactionPayload;
use crate::protos::IntoBytes;
use crate::protos::IntoProto;

use super::error::PlaylistError;

macro_rules! yaml_map(
 { $($key:expr => $value:expr),+ } => {
     {
         let mut m = Hash::new();
         $(m.insert(Yaml::from_str($key), $value);)+
         Yaml::Hash(m)
     }
 };
);

/// Generates a playlist of Smallbank transactions.
///
/// This function generates a collection of smallbank transactions and writes
/// the result to the given output.  The resulting playlist will consist of
/// `num_accounts` CREATE_ACCOUNT transactions, followed by `num_transactions`
/// additional transactions (deposits, transfers, etc).
///
/// A random seed may be provided to create repeatable, random output.
pub fn generate_smallbank_playlist(
    output: &mut dyn Write,
    num_accounts: usize,
    num_transactions: usize,
    seed: Option<i32>,
) -> Result<(), PlaylistError> {
    let mut fmt_writer = FmtWriter::new(output);
    let mut emitter = YamlEmitter::new(&mut fmt_writer);

    let txn_array: Vec<Yaml> = create_smallbank_playlist(num_accounts, num_transactions, seed)
        .map(Yaml::from)
        .collect();

    let final_yaml = Yaml::Array(txn_array);
    emitter
        .dump(&final_yaml)
        .map_err(PlaylistError::YamlOutputError)?;

    Ok(())
}

/// Created signed Smallbank transactions from a given playlist.
///
/// The playlist input is expected to be the same Yaml format as generated by
/// the `generate_smallbank_playlist` function.  All transactions will be
/// signed with the given `Signer` instance.
pub fn process_smallbank_playlist(
    output: &mut dyn Write,
    playlist_input: &mut dyn Read,
    signer: &dyn Signer,
) -> Result<(), PlaylistError> {
    let payloads = read_smallbank_playlist(playlist_input)?;

    let start = Instant::now();
    for payload in payloads {
        let elapsed = start.elapsed();
        let addresses = make_addresses(&payload);

        let payload_bytes = payload
            .into_bytes()
            .map_err(PlaylistError::ProtoConversionError)?;

        let txn = ExecuteContractActionBuilder::new()
            .with_name(String::from("smallbank"))
            .with_version(String::from("1.0"))
            .with_inputs(addresses.clone())
            .with_outputs(addresses.clone())
            .with_payload(payload_bytes)
            .into_payload_builder()
            .map_err(|err| {
                PlaylistError::BuildError(format!(
                    "Unable to convert execute action into sabre payload: {}",
                    err
                ))
            })?
            .into_transaction_builder()
            .map_err(|err| {
                PlaylistError::BuildError(format!(
                    "Unable to convert execute payload into transaction: {}",
                    err
                ))
            })?
            .with_nonce(
                format!("{}{}", elapsed.as_secs(), elapsed.subsec_nanos())
                    .as_bytes()
                    .to_vec(),
            )
            .build(&*signer)
            .map_err(|err| {
                PlaylistError::BuildError(format!("Unable to build transaction: {}", err))
            })?;

        let txn_proto = txn.into_proto().map_err(|err| {
            PlaylistError::BuildError(format!(
                "Unable to convert transaction to protobuf: {}",
                err
            ))
        })?;

        txn_proto
            .write_length_delimited_to_writer(output)
            .map_err(PlaylistError::MessageError)?
    }

    Ok(())
}

pub fn make_addresses(payload: &SmallbankTransactionPayload) -> Vec<String> {
    match payload {
        SmallbankTransactionPayload::CreateAccountTransactionData(payload) => {
            vec![customer_id_address(*payload.customer_id())]
        }
        SmallbankTransactionPayload::DepositCheckingTransactionData(payload) => {
            vec![customer_id_address(*payload.customer_id())]
        }
        SmallbankTransactionPayload::WriteCheckTransactionData(payload) => {
            vec![customer_id_address(*payload.customer_id())]
        }
        SmallbankTransactionPayload::TransactSavingsTransactionData(payload) => {
            vec![customer_id_address(*payload.customer_id())]
        }
        SmallbankTransactionPayload::SendPaymentTransactionData(payload) => vec![
            customer_id_address(*payload.source_customer_id()),
            customer_id_address(*payload.dest_customer_id()),
        ],
        SmallbankTransactionPayload::AmalgamateTransactionData(payload) => vec![
            customer_id_address(*payload.source_customer_id()),
            customer_id_address(*payload.dest_customer_id()),
        ],
    }
}

fn customer_id_address(customer_id: u32) -> String {
    let mut sha = Sha512::new();
    sha.update(customer_id.to_string().as_bytes());
    let hash = &mut sha.finalize();

    let hex = bytes_to_hex_str(hash);
    // Using the precomputed Sha512 hash of "smallbank"
    String::from("332514") + &hex[0..64]
}

pub fn create_smallbank_playlist(
    num_accounts: usize,
    num_transactions: usize,
    seed: Option<i32>,
) -> Box<dyn Iterator<Item = SmallbankTransactionPayload>> {
    let rng = match seed {
        Some(seed) => StdRng::seed_from_u64(seed as u64),
        None => StdRng::from_entropy(),
    };

    let iter = SmallbankGeneratingIter {
        num_accounts,
        current_account: 0,
        rng,
        accounts: vec![],
    };

    Box::new(iter.take(num_transactions))
}

pub fn read_smallbank_playlist(
    input: &mut dyn Read,
) -> Result<Vec<SmallbankTransactionPayload>, PlaylistError> {
    let mut results = Vec::new();
    let buf = read_yaml(input)?;
    let yaml_array = load_yaml_array(&buf)?;
    for yaml in yaml_array.iter() {
        results.push(SmallbankTransactionPayload::from(yaml));
    }

    Ok(results)
}

fn read_yaml(input: &mut dyn Read) -> Result<Cow<str>, PlaylistError> {
    let mut buf: String = String::new();
    input
        .read_to_string(&mut buf)
        .map_err(PlaylistError::IoError)?;
    Ok(buf.into())
}

fn load_yaml_array(yaml_str: &str) -> Result<Cow<Vec<Yaml>>, PlaylistError> {
    let mut yaml = YamlLoader::load_from_str(yaml_str).map_err(PlaylistError::YamlInputError)?;
    let element = yaml.remove(0);
    let yaml_array = element.as_vec().cloned().unwrap();

    Ok(Cow::Owned(yaml_array))
}

pub struct SmallbankGeneratingIter {
    num_accounts: usize,
    current_account: usize,
    rng: StdRng,
    accounts: Vec<u32>,
}

impl SmallbankGeneratingIter {
    pub fn new(num_accounts: usize, seed: u64) -> Self {
        SmallbankGeneratingIter {
            num_accounts,
            current_account: 0,
            rng: SeedableRng::seed_from_u64(seed),
            accounts: vec![],
        }
    }
}

impl Iterator for SmallbankGeneratingIter {
    type Item = SmallbankTransactionPayload;

    fn next(&mut self) -> Option<Self::Item> {
        if self.current_account < self.num_accounts {
            let customer_id: u32 = self.rng.gen_range(0, u32::MAX);
            self.accounts.push(customer_id);

            let create_account = smallbank::CreateAccount::new(
                customer_id,
                self.rng
                    .sample_iter(&rand::distributions::Alphanumeric)
                    .take(20)
                    .collect(),
                1_000_000,
                1_000_000,
            );

            self.current_account += 1;
            Some(SmallbankTransactionPayload::CreateAccountTransactionData(
                create_account,
            ))
        } else {
            let payload_type: PayloadType = self.rng.gen();

            match payload_type {
                PayloadType::DepositChecking => {
                    let deposit_checking: smallbank::DepositChecking =
                        make_smallbank_deposit_checking_txn(
                            &mut self.rng,
                            self.num_accounts,
                            &self.accounts,
                        );
                    Some(SmallbankTransactionPayload::DepositCheckingTransactionData(
                        deposit_checking,
                    ))
                }
                PayloadType::WriteCheck => {
                    let write_check: smallbank::WriteCheck = make_smallbank_write_check_txn(
                        &mut self.rng,
                        self.num_accounts,
                        &self.accounts,
                    );
                    Some(SmallbankTransactionPayload::WriteCheckTransactionData(
                        write_check,
                    ))
                }
                PayloadType::TransactSavings => {
                    let transact_savings: smallbank::TransactSavings =
                        make_smallbank_transact_savings_txn(
                            &mut self.rng,
                            self.num_accounts,
                            &self.accounts,
                        );
                    Some(SmallbankTransactionPayload::TransactSavingsTransactionData(
                        transact_savings,
                    ))
                }
                PayloadType::SendPayment => {
                    let send_payment: smallbank::SendPayment = make_smallbank_send_payment_txn(
                        &mut self.rng,
                        self.num_accounts,
                        &self.accounts,
                    );
                    Some(SmallbankTransactionPayload::SendPaymentTransactionData(
                        send_payment,
                    ))
                }
                PayloadType::Amalgamate => {
                    let amalgamate: smallbank::Amalgamate = make_smallbank_amalgamate_txn(
                        &mut self.rng,
                        self.num_accounts,
                        &self.accounts,
                    );
                    Some(SmallbankTransactionPayload::AmalgamateTransactionData(
                        amalgamate,
                    ))
                }
            }
        }
    }
}

impl From<SmallbankTransactionPayload> for Yaml {
    fn from(payload: SmallbankTransactionPayload) -> Self {
        match payload {
            SmallbankTransactionPayload::CreateAccountTransactionData(data) => {
                yaml_map! {
                "transaction_type" => Yaml::from_str("create_account"),
                "customer_id" => Yaml::Integer(*data.customer_id() as i64),
                "customer_name" => Yaml::String(String::from(data.customer_name())),
                "initial_savings_balance" =>
                    Yaml::Integer(*data.initial_savings_balance() as i64),
                "initial_checking_balance" =>
                    Yaml::Integer(*data.initial_checking_balance() as i64)}
            }
            SmallbankTransactionPayload::DepositCheckingTransactionData(data) => {
                yaml_map! {
                "transaction_type" => Yaml::from_str("deposit_checking"),
                "customer_id" => Yaml::Integer(*data.customer_id() as i64),
                "amount" => Yaml::Integer(*data.amount() as i64)}
            }
            SmallbankTransactionPayload::WriteCheckTransactionData(data) => {
                yaml_map! {
                "transaction_type" => Yaml::from_str("write_check"),
                "customer_id" => Yaml::Integer(*data.customer_id() as i64),
                "amount" => Yaml::Integer(*data.amount() as i64)}
            }
            SmallbankTransactionPayload::TransactSavingsTransactionData(data) => {
                yaml_map! {
                "transaction_type" => Yaml::from_str("transact_savings"),
                "customer_id" => Yaml::Integer(*data.customer_id() as i64),
                "amount" => Yaml::Integer(*data.amount() as i64)}
            }
            SmallbankTransactionPayload::SendPaymentTransactionData(data) => {
                yaml_map! {
                "transaction_type" => Yaml::from_str("send_payment"),
                "source_customer_id" => Yaml::Integer(*data.source_customer_id() as i64),
                "dest_customer_id" => Yaml::Integer(*data.dest_customer_id() as i64),
                "amount" => Yaml::Integer(*data.amount() as i64)}
            }
            SmallbankTransactionPayload::AmalgamateTransactionData(data) => {
                yaml_map! {
                "transaction_type" => Yaml::from_str("amalgamate"),
                "source_customer_id" => Yaml::Integer(*data.source_customer_id() as i64),
                "dest_customer_id" => Yaml::Integer(*data.dest_customer_id() as i64)}
            }
        }
    }
}

impl<'a> From<&'a Yaml> for SmallbankTransactionPayload {
    fn from(yaml: &Yaml) -> Self {
        if let Some(txn_hash) = yaml.as_hash() {
            match txn_hash[&Yaml::from_str("transaction_type")].as_str() {
                Some("create_account") => {
                    let customer_id =
                        txn_hash[&Yaml::from_str("customer_id")].as_i64().unwrap() as u32;
                    let customer_name = txn_hash[&Yaml::from_str("customer_name")]
                        .as_str()
                        .unwrap()
                        .to_string();
                    let initial_savings_balance = txn_hash
                        [&Yaml::from_str("initial_savings_balance")]
                        .as_i64()
                        .unwrap() as u32;
                    let initial_checking_balance = txn_hash
                        [&Yaml::from_str("initial_checking_balance")]
                        .as_i64()
                        .unwrap() as u32;

                    let create_account = smallbank::CreateAccount::new(
                        customer_id,
                        customer_name,
                        initial_savings_balance,
                        initial_checking_balance,
                    );

                    SmallbankTransactionPayload::CreateAccountTransactionData(create_account)
                }

                Some("deposit_checking") => {
                    let customer_id =
                        txn_hash[&Yaml::from_str("customer_id")].as_i64().unwrap() as u32;
                    let amount = txn_hash[&Yaml::from_str("amount")].as_i64().unwrap() as u32;

                    let deposit_checking = smallbank::DepositChecking::new(customer_id, amount);

                    SmallbankTransactionPayload::DepositCheckingTransactionData(deposit_checking)
                }

                Some("write_check") => {
                    let customer_id =
                        txn_hash[&Yaml::from_str("customer_id")].as_i64().unwrap() as u32;
                    let amount = txn_hash[&Yaml::from_str("amount")].as_i64().unwrap() as u32;

                    let write_check = smallbank::WriteCheck::new(customer_id, amount);

                    SmallbankTransactionPayload::WriteCheckTransactionData(write_check)
                }

                Some("transact_savings") => {
                    let customer_id =
                        txn_hash[&Yaml::from_str("customer_id")].as_i64().unwrap() as u32;
                    let amount = txn_hash[&Yaml::from_str("amount")].as_i64().unwrap() as i32;

                    let transact_savings = smallbank::TransactSavings::new(customer_id, amount);

                    SmallbankTransactionPayload::TransactSavingsTransactionData(transact_savings)
                }

                Some("send_payment") => {
                    let source_customer_id = txn_hash[&Yaml::from_str("source_customer_id")]
                        .as_i64()
                        .unwrap() as u32;
                    let dest_customer_id = txn_hash[&Yaml::from_str("dest_customer_id")]
                        .as_i64()
                        .unwrap() as u32;
                    let amount = txn_hash[&Yaml::from_str("amount")].as_i64().unwrap() as u32;

                    let send_payment =
                        smallbank::SendPayment::new(source_customer_id, dest_customer_id, amount);

                    SmallbankTransactionPayload::SendPaymentTransactionData(send_payment)
                }

                Some("amalgamate") => {
                    let source_customer_id = txn_hash[&Yaml::from_str("source_customer_id")]
                        .as_i64()
                        .unwrap() as u32;
                    let dest_customer_id = txn_hash[&Yaml::from_str("dest_customer_id")]
                        .as_i64()
                        .unwrap() as u32;

                    let amalgamate =
                        smallbank::Amalgamate::new(source_customer_id, dest_customer_id);

                    SmallbankTransactionPayload::AmalgamateTransactionData(amalgamate)
                }
                Some(txn_type) => panic!("unknown transaction_type: {}", txn_type),
                None => panic!("No transaction_type specified"),
            }
        } else {
            panic!("should be a hash map!")
        }
    }
}

fn make_smallbank_deposit_checking_txn(
    rng: &mut StdRng,
    num_accounts: usize,
    accounts: &[u32],
) -> smallbank::DepositChecking {
    // value in range should always exist
    smallbank::DepositChecking::new(
        accounts[rng.gen_range(0, num_accounts)],
        rng.gen_range(10, 200),
    )
}

fn make_smallbank_write_check_txn(
    rng: &mut StdRng,
    num_accounts: usize,
    accounts: &[u32],
) -> smallbank::WriteCheck {
    // value in range should always exist
    smallbank::WriteCheck::new(
        accounts[rng.gen_range(0, num_accounts)],
        rng.gen_range(10, 200),
    )
}

fn make_smallbank_transact_savings_txn(
    rng: &mut StdRng,
    num_accounts: usize,
    accounts: &[u32],
) -> smallbank::TransactSavings {
    // value in range should always exist
    smallbank::TransactSavings::new(
        accounts[rng.gen_range(0, num_accounts)],
        rng.gen_range(10, 200),
    )
}

fn make_smallbank_send_payment_txn(
    rng: &mut StdRng,
    num_accounts: usize,
    accounts: &[u32],
) -> smallbank::SendPayment {
    // value in range should always exist
    let source = rng.gen_range(0, num_accounts);
    let dest = next_non_matching_in_range(rng, num_accounts, source);

    smallbank::SendPayment::new(accounts[source], accounts[dest], rng.gen_range(10, 200))
}

fn make_smallbank_amalgamate_txn(
    rng: &mut StdRng,
    num_accounts: usize,
    accounts: &[u32],
) -> smallbank::Amalgamate {
    // value in range should always exist
    let source = rng.gen_range(0, num_accounts);
    let dest = next_non_matching_in_range(rng, num_accounts, source);

    smallbank::Amalgamate::new(accounts[source], accounts[dest])
}

fn next_non_matching_in_range(rng: &mut StdRng, max: usize, exclude: usize) -> usize {
    let mut selected = exclude;
    while selected == exclude {
        selected = rng.gen_range(0, max)
    }
    selected
}

struct FmtWriter<'a> {
    writer: &'a mut dyn Write,
}

impl<'a> FmtWriter<'a> {
    pub fn new(writer: &'a mut dyn Write) -> Self {
        FmtWriter { writer }
    }
}

impl<'a> fmt::Write for FmtWriter<'a> {
    fn write_str(&mut self, s: &str) -> Result<(), fmt::Error> {
        let w = &mut *self.writer;
        w.write_all(s.as_bytes()).map_err(|_| fmt::Error::default())
    }
}

pub fn bytes_to_hex_str(b: &[u8]) -> String {
    b.iter()
        .map(|b| format!("{:02x}", b))
        .collect::<Vec<_>>()
        .join("")
}

#[derive(Debug, PartialEq)]
enum PayloadType {
    DepositChecking,
    WriteCheck,
    TransactSavings,
    SendPayment,
    Amalgamate,
}

impl Distribution<PayloadType> for Standard {
    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> PayloadType {
        match rng.gen_range(2, 7) {
            3 => PayloadType::DepositChecking,
            4 => PayloadType::WriteCheck,
            5 => PayloadType::TransactSavings,
            6 => PayloadType::SendPayment,
            _ => PayloadType::Amalgamate,
        }
    }
}
